dtmc

const double s1_failure_rate = 0.030901838378906248;
const double s1_persistent_failure_rate = 0.02;
const double s1_persistent_recovery_rate = 0.11;

const double alarm_frequency = 1/3;

module synchronisation
    sync_s: [0..3] init 0;
    [set_service1] sync_s = 0 -> 1 : (sync_s'=1);
    [set_alarm_sender] sync_s = 1 -> 1 : (sync_s'=2);
    [start_UAC] sync_s = 2 -> 1 : (sync_s'=3);
    [end_round] sync_s = 3 -> 1 : (sync_s'=0);
endmodule

module service1
    s1: [0..2] init 0;
    [set_service1] s1 <= 1 ->  s1_failure_rate: (s1'=1) + s1_persistent_failure_rate: (s1'=2) + 1-s1_failure_rate-s1_persistent_failure_rate: (s1'=0);
    [set_service1] s1 = 2  ->  s1_persistent_recovery_rate: (s1'=0) + 1-s1_persistent_recovery_rate: (s1'=2);
endmodule

module alarm_sender
    alarm: [0..1] init 0;
    [set_alarm_sender] true -> alarm_frequency: (alarm'=1) + 1-alarm_frequency: (alarm'=0);
endmodule

// UAC
module adaptation_MAPE_controller
    uac_s: [0..2] init 0;

    [start_UAC] uac_s = 0 -> (uac_s' = 1);

    // Alarm
    [s1_invokation] uac_s = 1 &   s1_needs_invokation & s1 = 0              -> 1: (uac_s' = 2);
    [s1_invokation] uac_s = 1 &   s1_needs_invokation & s1 > 0 & s1hat <= 2 -> 1: (uac_s' = 2);
    [             ] uac_s = 1 & ! s1_needs_invokation                       -> 1: (uac_s' = 2);
    // Reset
    [end_round] uac_s = 2 -> (uac_s' = 0);
endmodule

module Knowledge
    s1hat: [0..2] init 0;

    [s1_invokation] s1 = 0 -> (s1hat' = 0);
    [s1_invokation] s1 > 0 & s1hat <= 2 -> (s1hat' = min((s1hat + 1),2));
    [update_s1] true -> (s1hat' = s1);
endmodule

formula s1_needs_invokation = alarm = 1;

// Rewards
rewards "total_invokations"
    [s1_invokation] true: 1;
endrewards

rewards "s1_invokations"
    [s1_invokation] true: 1;
endrewards

rewards "total_costs"
    [s1_invokation] true: 2;
    [update_s1] true: 2;
endrewards

rewards "model_drift"
    [end_round] s1 != s1hat: 1;
endrewards

rewards "model_drift_pessimistic"
    [end_round] s1 < s1hat: 1;
endrewards

rewards "model_drift_optimistic"
    [end_round] s1 > s1hat: 1;
endrewards

rewards "alarms"
    [end_round] alarm = 1: 1;
endrewards

rewards "time_per_alarm"
    [s1_invokation] alarm = 1 & s1 = 0: 1;
    [s1_invokation] alarm = 1 & s1 > 0: 3;
endrewards

evolve int decision_0_s1 [1..10];
evolve int decision_1_s1 [1..10];
evolve int decision_2_s1 [1..10];

module UMC
  step_s1 : [1..10] init 1;
  [no_update_s1] (step_s1<decision_0_s1) & (s1hat=0) -> (step_s1'=step_s1+1);
  [no_update_s1] (step_s1<decision_1_s1) & (s1hat=1) -> (step_s1'=step_s1+1);
  [no_update_s1] (step_s1<decision_2_s1) & (s1hat=2) -> (step_s1'=step_s1+1);
  [update_s1] (step_s1>=decision_0_s1) & (s1hat=0) -> (step_s1'=1);
  [update_s1] (step_s1>=decision_1_s1) & (s1hat=1) -> (step_s1'=1);
  [update_s1] (step_s1>=decision_2_s1) & (s1hat=2) -> (step_s1'=1);
endmodule

module Turn
  t : [0..2] init 0;
  [start_UAC] (t=0) -> (t'=1);

  [no_update_s1] (t=1) -> (t'=2);
  [update_s1] (t=1) -> (t'=2);

  [end_round] (t=2) -> (t'=0);
endmodule
